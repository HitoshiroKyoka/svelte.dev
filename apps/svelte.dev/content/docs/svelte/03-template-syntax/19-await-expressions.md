---
NOTE: do not edit this file, it is generated in apps/svelte.dev/scripts/sync-docs/index.ts
title: await
---

Svelte5.36 以降、コンポーネント内のうち、これまで使えなかった3箇所で `await` キーワードを使えるようになりました:

- コンポーネントの `<script>` トップレベル
-  `$derived(...)` 宣言の内部
- マークアップの内部

この機能は実験的なものであり、Svelteの[設定](/docs/kit/configuration)(通常は `svelte.config.js`)に `experimental.async` オプションを追加して、明示的に有効にする必要があります:

```js
/// file: svelte.config.js
export default {
	compilerOptions: {
		experimental: {
			async: true
		}
	}
};
```

この実験的なフラグは Svelte 6 で削除される予定です。

## 同期された更新 <!--Synchronized-updates-->

ある `await` 式が特定の state に依存しているとき、その state への変更は、非同期処理が完了するまでUIに反映されません。UIが矛盾した状態にならないようにするためです。つまり、[こちら](/playground/untitled#H4sIAAAAAAAAE42QsWrDQBBEf2VZUkhYRE4gjSwJ0qVMkS6XYk9awcFpJe5Wdoy4fw-ycdykSPt2dpiZFYVGxgrf2PsJTlPwPWTcO-U-xwIH5zli9bminudNtwEsbl-v8_wYj-x1Y5Yi_8W7SZRFI1ZYxy64WVsjRj0rEDTwEJWUs6f8cKP2Tp8vVIxSPEsHwyKdukmA-j6jAmwO63Y1SidyCsIneA_T6CJn2ZBD00Jk_XAjT4tmQwEv-32eH6AsgYK6wXWOPPTs6Xy1CaxLECDYgb3kSUbq8p5aaifzorCt0RiUZbQcDIJ10ldH8gs3K6X2Xzqbro5zu1KCHaw2QQPrtclvwVSXc2sEC1T-Vqw0LJy-ClRy_uSkx2ogHzn9ADZ1CubKAQAA)のような例では...

```svelte
<script>
	let a = $state(1);
	let b = $state(2);

	async function add(a, b) {
		await new Promise((f) => setTimeout(f, 500)); // artificial delay
		return a + b;
	}
</script>

<input type="number" bind:value={a}>
<input type="number" bind:value={b}>

<p>{a} + {b} = {await add(a, b)}</p>
```

...`a` の値をインクリメントしても、 `<p>` の内容は次のようには _なりません。_

```html
<p>2 + 2 = 3</p>
```

実際には、`add(a, b)`が解決されたときに、`<p>`の内容を `2 + 2 = 4` に更新します。

更新は重複することがあります。先行する更新が遅く、まだ進行中であっても、続く更新が速ければ、速いほうが先にUIに反映されます。

## 並行性 <!--Concurrency-->

Svelte は可能な限り非同期処理を並行におこないます。例えば、マークアップ内に2つの `await` 式があるとき...

```svelte
<p>{await one()}</p>
<p>{await two()}</p>
```

...それらは独立した式ですので、 _見た目上は_ 順次実行されているように見えても、両方の関数が同時に実行されます。

これは、`<script>` 内や非同期関数内の連続した `await` 式には適用されません。これらは他の非同期JavaScriptと同じように実行されます。例外として、独立した `$derived` 式は、最初の作成時には順次実行されますが、そのあとは独立して更新されます:

```js
async function one() { return 1; }
async function two() { return 2; }
// ---cut---
// これらは最初は順次実行されますが、
// そのあとは独立して更新されます
let a = $derived(await one());
let b = $derived(await two());
```

> [!NOTE] このようなコードを書くと、Svelteから [`await_waterfall`](runtime-warnings#Client-warnings-await_waterfall) 警告が表示されます。

## ローディング状態の表示 <!--Indicating-loading-states-->

To render placeholder UI, you can wrap content in a `<svelte:boundary>` with a [`pending`](svelte-boundary#Properties-pending) snippet. This will be shown when the boundary is first created, but not for subsequent updates, which are globally coordinated.

After the contents of a boundary have resolved for the first time and have replaced the `pending` snippet, you can detect subsequent async work with [`$effect.pending()`]($effect#$effect.pending). This is what you would use to display a "we're asynchronously validating your input" spinner next to a form field, for example.

また、 [`settled()`](svelte#settled) を使うと、現在の更新が完了したときに解決(resolve)される Promise を取得できます:

```js
let color = 'red';
let answer = -1;
let updating = false;
// ---cut---
import { tick, settled } from 'svelte';

async function onclick() {
	updating = true;

	// これがないと、`updating` への変更は
	// 他の変更とまとめられてしまうため、
	// UI に反映されません
	await tick();

	color = 'octarine';
	answer = 42;

	await settled();

	// `color` や `answer` の変更に影響される
	// あらゆる更新が、この時点で適用済みになります
	updating = false;
}
```

## エラーハンドリング <!--Error-handling-->

`await` 式のエラーは、もっとも近い [error boundary](svelte-boundary) に伝播します。

## Server-side rendering

Svelte supports asynchronous server-side rendering (SSR) with the `render(...)` API. To use it, simply await the return value:

```js
/// file: server.js
import { render } from 'svelte/server';
import App from './App.svelte';

const { head, body } = +++await+++ render(App);
```

> [!NOTE] If you're using a framework like SvelteKit, this is done on your behalf.

If a `<svelte:boundary>` with a `pending` snippet is encountered during SSR, that snippet will be rendered while the rest of the content is ignored. All `await` expressions encountered outside boundaries with `pending` snippets will resolve and render their contents prior to `await render(...)` returning.

> [!NOTE] In the future, we plan to add a streaming implementation that renders the content in the background.

## 注意事項 <!--Caveats-->

実験的な機能であるため、 `await` 扱いの詳細(および `$effect.pending()` のような関連API)は、セマンティックバージョニングのメジャーリリース外では破壊的変更がおこなわれる可能性があります。ただし、そのような変更は最小限に抑えるつもりです。

## 破壊的変更 <!--Breaking-changes-->

`experimental.async` オプションが `true` のとき、効果の実行順序がわずかに異なります。具体的には、 `{#if ...}` や `{#each ...}` のような _ブロック_ の効果を、 `$effect.pre` や `beforeUpdate` の前に実行するようになります。これにより、[非常にまれな状況](/playground/untitled?#H4sIAAAAAAAAE22R3VLDIBCFX2WLvUhnTHsf0zre-Q7WmfwtFV2BgU1rJ5N3F0jaOuoVcPbw7VkYhK4_URTiGYkMnIyjDjLsFGO3EvdCKkIvipdB8NlGXxSCPt96snbtj0gctab2-J_eGs2oOWBE6VunLO_2es-EDKZ5x5ZhC0vPNWM2gHXGouNzAex6hHH1cPHil_Lsb95YT9VQX6KUAbS2DrNsBdsdDFHe8_XSYjH1SrhELTe3MLpsemajweiWVPuxHSbKNd-8eQTdE0EBf4OOaSg2hwNhhE_ABB_ulJzjj9FULvIcqgm5vnAqUB7wWFMfhuugQWkcAr8hVD-mq8D12kOep24J_IszToOXdveGDsuNnZwbJUNlXsKnhJdhUcTo42s41YpOSneikDV5HL8BktM6yRcCAAA=)では、存在しないはずのブロックを更新してしまう可能性があります。ただし、これは効果内で state を更新した場合に限られますし、[そのような状況は避けるべきです]($effect#When-not-to-use-$effect)。
